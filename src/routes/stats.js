// server/src/routes/stats.js

const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');
const authMiddleware = require('./authMiddleware');
const ScriptHistory = require('../models/ScriptHistory');
const { listUserVideosFromS3, listUserImagesFromS3 } = require('../s3Service');
const Video = require('../models/Video');

// Helper: parse date or return undefined
function parseDate(dateStr) {
  if (!dateStr) return undefined;
  const d = new Date(dateStr);
  return isNaN(d.getTime()) ? undefined : d;
}

// GET /api/stats/summary
router.get('/summary', authMiddleware, async (req, res) => {
  try {
    const { videoType = 'all', startDate, endDate } = req.query;
    const userId = req.user._id;
    const filter = { userId };

    // Date filtering
    const start = parseDate(startDate);
    const end = parseDate(endDate);
    if (start || end) {
      filter.createdAt = {};
      if (start) filter.createdAt.$gte = start;
      if (end) filter.createdAt.$lte = end;
    }

    // Count videos (scripts) generated by user
    const totalVideos = await ScriptHistory.countDocuments(filter);

    // For extensibility: add more aggregation if metadata contains stats
    // Count AI videos generated (from S3)
    let totalAIVideos = 0;
    let totalAIImages = 0;
    try {
      const username = req.user && req.user.username ? req.user.username : '';
      const videos = await listUserVideosFromS3(userId, username);
      const images = await listUserImagesFromS3(userId, username);
      totalAIVideos = Array.isArray(videos) ? videos.length : 0;
      totalAIImages = Array.isArray(images) ? images.length : 0;
    } catch (e) {
      totalAIVideos = 0;
      totalAIImages = 0;
    }

    // Count published videos for this user (publishedToYouTube true OR publishCount > 0)
    const publishedFilter = {
      owner: mongoose.Types.ObjectId.isValid(userId) ? new mongoose.Types.ObjectId(userId) : userId,
      $or: [
        { publishedToYouTube: true },
        { publishCount: { $gt: 0 } }
      ]
    };
    const publishedCount = await Video.countDocuments(publishedFilter);

    res.json({
      stats: [
        {
          title: "AI Videos Generated",
          value: totalAIVideos,
          change: "",
          changeType: "positive",
          comparison: "vs previous"
        },
        {
          title: "AI Images Generated",
          value: totalAIImages,
          change: "",
          changeType: "positive",
          comparison: "vs previous"
        },
        {
          title: "Scripts Generated",
          value: totalVideos,
          change: "",
          changeType: "positive",
          comparison: "vs previous"
        },
        {
          title: "Videos Published to YouTube",
          value: publishedCount,
          change: "",
          changeType: "positive",
          comparison: "vs previous"
        },
        {
          title: "Videos Published to Instagram",
          value: 0,
          change: "",
          changeType: "positive",
          comparison: "vs previous"
        }
      ]
    });
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch summary stats.' });
  }
});

// GET /api/stats/timeseries
router.get('/timeseries', authMiddleware, async (req, res) => {
  try {
    const { startDate, endDate, interval = 'day' } = req.query;
    const userId = req.user._id;

    // Prepare date filtering for both models
    const start = parseDate(startDate);
    const end = parseDate(endDate);

    // Helper for date filtering
    function buildDateMatch(field) {
      const match = {};
      if (start || end) {
        match[field] = {};
        if (start) match[field].$gte = start;
        if (end) match[field].$lte = end;
      }
      return match;
    }

  // Group by day for createdAt
  const groupFormat = { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } };
  // Group by day for lastPublishedAt
  const groupPublishedFormat = { $dateToString: { format: "%Y-%m-%d", date: "$lastPublishedAt" } };

    // 1. Scripts generated per day
    const scriptMatch = { userId: userId.toString(), ...buildDateMatch('createdAt') };
    const scriptAgg = await ScriptHistory.aggregate([
      { $match: scriptMatch },
      { $group: { _id: groupFormat, count: { $sum: 1 } } },
      { $sort: { _id: 1 } }
    ]);

        // 2. AI Videos generated per day (from S3)
        let aiVideoAgg = [];
        let aiImageAgg = [];
        try {
          const username = req.user && req.user.username ? req.user.username : '';
          const s3Videos = await listUserVideosFromS3(userId, username);
          const s3Images = await listUserImagesFromS3(userId, username);
    
          // Group by day for videos
          const aiVideoMap = {};
          s3Videos.forEach(v => {
            let dateObj = v.createdAt ? new Date(v.createdAt) : (v.CreationDate ? new Date(v.CreationDate) : (v.LastModified ? new Date(v.LastModified) : null));
            if (!dateObj || isNaN(dateObj.getTime())) return;
            if ((start && dateObj < start) || (end && dateObj > end)) return;
            const dateStr = dateObj.toISOString().slice(0, 10);
            aiVideoMap[dateStr] = (aiVideoMap[dateStr] || 0) + 1;
          });
          aiVideoAgg = Object.entries(aiVideoMap).map(([date, count]) => ({ _id: date, count }));
          aiVideoAgg.sort((a, b) => a._id.localeCompare(b._id));

          // Group by day for images
          const aiImageMap = {};
          s3Images.forEach(img => {
            let dateObj = img.createdAt ? new Date(img.createdAt) : (img.CreationDate ? new Date(img.CreationDate) : (img.LastModified ? new Date(img.LastModified) : null));
            if (!dateObj || isNaN(dateObj.getTime())) return;
            if ((start && dateObj < start) || (end && dateObj > end)) return;
            const dateStr = dateObj.toISOString().slice(0, 10);
            aiImageMap[dateStr] = (aiImageMap[dateStr] || 0) + 1;
          });
          aiImageAgg = Object.entries(aiImageMap).map(([date, count]) => ({ _id: date, count }));
          aiImageAgg.sort((a, b) => a._id.localeCompare(b._id));
        } catch (e) {
          aiVideoAgg = [];
          aiImageAgg = [];
        }

    // 3. Published videos per day (group by lastPublishedAt)
    const publishedMatch = {
      owner: mongoose.Types.ObjectId.isValid(userId) ? new mongoose.Types.ObjectId(userId) : userId,
      $or: [{ publishedToYouTube: true }, { publishCount: { $gt: 0 } }],
      lastPublishedAt: { $exists: true, $ne: null }
    };

    // Add date range filtering without overwriting lastPublishedAt
    const dateFilter = buildDateMatch('lastPublishedAt');
    if (dateFilter.lastPublishedAt) {
      publishedMatch.lastPublishedAt = {
        ...publishedMatch.lastPublishedAt,
        ...dateFilter.lastPublishedAt
      };
    }

    // Debug: print matched published videos
    const publishedDocs = await Video.find(publishedMatch).lean();
    console.log('[stats/timeseries] publishedMatch query:', JSON.stringify(publishedMatch, null, 2));
    console.log('[stats/timeseries] userId type:', typeof userId, 'value:', userId);
    console.log('[stats/timeseries] Matched published videos:', publishedDocs.map(v => ({
      s3Key: v.s3Key,
      owner: v.owner,
      lastPublishedAt: v.lastPublishedAt,
      createdAt: v.createdAt,
      publishCount: v.publishCount,
      publishedToYouTube: v.publishedToYouTube
    })));
    const publishedAgg = await Video.aggregate([
      { $match: publishedMatch },
      { $group: { _id: groupPublishedFormat, count: { $sum: 1 } } },
      { $sort: { _id: 1 } }
    ]);

        // Merge all dates
        const dateSet = new Set();
        scriptAgg.forEach(d => dateSet.add(d._id));
        aiVideoAgg.forEach(d => dateSet.add(d._id));
        aiImageAgg.forEach(d => dateSet.add(d._id));
        publishedAgg.forEach(d => dateSet.add(d._id));
        const allDates = Array.from(dateSet).sort();

        // Build date -> count maps
        const scriptMap = Object.fromEntries(scriptAgg.map(d => [d._id, d.count]));
        const aiVideoMap = Object.fromEntries(aiVideoAgg.map(d => [d._id, d.count]));
        const aiImageMap = Object.fromEntries(aiImageAgg.map(d => [d._id, d.count]));
        const publishedMap = Object.fromEntries(publishedAgg.map(d => [d._id, d.count]));

        // Fill missing dates with zeroes
        const data = allDates.map(date => ({
          date,
          label: date, // for recharts XAxis
          aiVideosGeneratedCount: aiVideoMap[date] || 0,
          aiImagesGeneratedCount: aiImageMap[date] || 0,
          scriptGeneratedCount: scriptMap[date] || 0,
          publishedCount: publishedMap[date] || 0
        }));

    res.json({
      interval: "day",
      data
    });
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch time-series stats.' });
  }
});

module.exports = router;